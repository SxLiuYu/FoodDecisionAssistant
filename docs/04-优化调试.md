# 04 - ä¼˜åŒ–è°ƒè¯•æŒ‡å—

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. æ¨¡å‹æ¨ç†ä¼˜åŒ–

#### å†…å­˜ç®¡ç†

```kotlin
// mnn/Qwen2VLModel.kt - ä¼˜åŒ–ç‰ˆ
class Qwen2VLModel(private val context: Context) {
    
    private var interpreter: Interpreter? = null
    private val memoryPool = TensorMemoryPool(maxSize = 3) // å¤ç”¨ Tensor å†…å­˜
    
    /**
     * ä½¿ç”¨å†…å­˜æ± ä¼˜åŒ– Tensor åˆ†é…
     */
    fun inferenceOptimized(image: Bitmap, prompt: String): String {
        // ä»æ± ä¸­è·å– Tensorï¼Œé¿å…é¢‘ç¹åˆ†é…
        val inputTensor = memoryPool.acquire(getInputShape())
        
        try {
            // å¡«å……æ•°æ®
            fillTensorData(inputTensor, image, prompt)
            
            // æ¨ç†
            return session?.run(inputTensor)?.let { parseOutput(it) } ?: ""
        } finally {
            // å½’è¿˜åˆ°æ± ä¸­
            memoryPool.release(inputTensor)
        }
    }
}

/**
 * Tensor å†…å­˜æ± 
 */
class TensorMemoryPool(private val maxSize: Int) {
    private val pool = ArrayDeque<Tensor>(maxSize)
    private val lock = Any()
    
    fun acquire(shape: IntArray): Tensor {
        synchronized(lock) {
            return pool.removeFirstOrNull()?.takeIf { it.shape.contentEquals(shape) }
                ?: createTensor(shape)
        }
    }
    
    fun release(tensor: Tensor) {
        synchronized(lock) {
            if (pool.size < maxSize) {
                pool.addLast(tensor)
            } else {
                tensor.dispose()
            }
        }
    }
}
```

#### å¼‚æ­¥æ¨ç†

```kotlin
// ui/MainViewModel.kt - å¼‚æ­¥ä¼˜åŒ–
class MainViewModel(application: Application) : AndroidViewModel(application) {
    
    private val inferenceDispatcher = Dispatchers.Default.limitedParallelism(1)
    
    /**
     * å¸¦è¶…æ—¶çš„æ¨ç†
     */
    private suspend fun inferenceWithTimeout(
        image: Bitmap, 
        prompt: String,
        timeoutMs: Long = 30000
    ): Result<String> = withTimeoutOrNull(timeoutMs) {
        withContext(inferenceDispatcher) {
            try {
                Result.success(model.inference(image, prompt))
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    } ?: Result.failure(TimeoutException("æ¨ç†è¶…æ—¶"))
}
```

#### é‡åŒ–ä¼˜åŒ–

```bash
# INT4 é‡åŒ–ï¼ˆå·²æ˜¯æœ€å°ï¼‰
# å¦‚éœ€è¿›ä¸€æ­¥å‹ç¼©ï¼Œå¯è€ƒè™‘ï¼š

# 1. åŠ¨æ€æ‰¹å¤„ç†ï¼ˆå¦‚æœæ”¯æŒï¼‰
# 2. çŸ¥è¯†è’¸é¦ï¼ˆè®­ç»ƒæ›´å°çš„å­¦ç”Ÿæ¨¡å‹ï¼‰
# 3. æ¨¡å‹å‰ªæ
```

### 2. UI ä¼˜åŒ–

#### å›¾ç‰‡åŠ è½½ä¼˜åŒ–

```kotlin
// ui/components/OptimizedImage.kt
@Composable
fun OptimizedImage(
    bitmap: Bitmap,
    modifier: Modifier = Modifier,
    maxDimension: Int = 1024
) {
    // é™åˆ¶æœ€å¤§å°ºå¯¸ï¼Œé¿å…å†…å­˜æº¢å‡º
    val scaledBitmap = remember(bitmap) {
        val scale = min(
            maxDimension.toFloat() / bitmap.width,
            maxDimension.toFloat() / bitmap.height
        ).coerceAtMost(1f)
        
        if (scale < 1f) {
            Bitmap.createScaledBitmap(
                bitmap,
                (bitmap.width * scale).toInt(),
                (bitmap.height * scale).toInt(),
                true
            )
        } else bitmap
    }
    
    Image(
        bitmap = scaledBitmap.asImageBitmap(),
        contentDescription = null,
        modifier = modifier
    )
}
```

#### åˆ—è¡¨æ‡’åŠ è½½

```kotlin
@Composable
fun RecommendationList(recommendations: List<Recommendation>) {
    LazyColumn {
        items(
            items = recommendations,
            key = { it.id }
        ) { recommendation ->
            RecommendationCard(recommendation)
        }
    }
}
```

### 3. æ•°æ®åº“ä¼˜åŒ–

```kotlin
// data/local/AppDatabase.kt - ä¼˜åŒ–ç‰ˆ
@Database(
    entities = [UserPreference::class, FoodHistory::class],
    version = 1,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    
    companion object {
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "food_assistant.db"
                )
                .addMigrations() // é¢„å®šä¹‰è¿ç§»ç­–ç•¥
                .setQueryExecutor(Executors.newFixedThreadPool(4)) // æŸ¥è¯¢çº¿ç¨‹æ± 
                .setTransactionExecutor(Executors.newSingleThreadExecutor())
                .build()
                .also { INSTANCE = it }
            }
        }
    }
}

// æ·»åŠ ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
@Entity(
    tableName = "food_history",
    indices = [Index(value = ["timestamp"], descending = true)]
)
data class FoodHistory(...)
```

## ğŸ” è°ƒè¯•æŠ€å·§

### 1. MNN æ—¥å¿—

```kotlin
// å¼€å¯è¯¦ç»†æ—¥å¿—
class MNNDebug {
    companion object {
        fun enableVerboseLogging() {
            // MNN å†…éƒ¨æ—¥å¿—
            System.setProperty("MNN_VERBOSE", "1")
            
            // Android æ—¥å¿—
            Log.d("MNN", "Verbose logging enabled")
        }
    }
}

// åœ¨ Application.onCreate ä¸­è°ƒç”¨
class FoodApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        if (BuildConfig.DEBUG) {
            MNNDebug.enableVerboseLogging()
        }
    }
}
```

### 2. æ€§èƒ½ç›‘æ§

```kotlin
// utils/PerformanceMonitor.kt
class PerformanceMonitor {
    
    private val timings = mutableMapOf<String, MutableList<Long>>()
    
    inline fun <T> measure(stage: String, block: () -> T): T {
        val start = SystemClock.elapsedRealtime()
        return try {
            block()
        } finally {
            val duration = SystemClock.elapsedRealtime() - start
            timings.getOrPut(stage) { mutableListOf() }.add(duration)
            Log.d("Perf", "$stage: ${duration}ms")
        }
    }
    
    fun report(): String {
        return timings.map { (stage, times) ->
            val avg = times.average()
            val max = times.maxOrNull() ?: 0
            "$stage: avg=${avg.toInt()}ms, max=${max}ms, count=${times.size}"
        }.joinToString("\n")
    }
}

// ä½¿ç”¨ç¤ºä¾‹
class MainViewModel(application: Application) : AndroidViewModel(application) {
    private val monitor = PerformanceMonitor()
    
    fun getRecommendation(image: Bitmap?, text: String?) {
        viewModelScope.launch {
            val result = monitor.measure("inference") {
                model.inference(image!!, text!!)
            }
            Log.d("Perf", monitor.report())
        }
    }
}
```

### 3. å†…å­˜åˆ†æ

```kotlin
// å†…å­˜æ³„æ¼æ£€æŸ¥
class MemoryWatcher {
    private val runtime = Runtime.getRuntime()
    
    fun logMemory(tag: String = "Memory") {
        val maxMemory = runtime.maxMemory() / 1024 / 1024
        val totalMemory = runtime.totalMemory() / 1024 / 1024
        val freeMemory = runtime.freeMemory() / 1024 / 1024
        val usedMemory = totalMemory - freeMemory
        
        Log.d(tag, "Max: ${maxMemory}MB, Used: ${usedMemory}MB, Free: ${freeMemory}MB")
    }
    
    fun watch(thresholdPercent: Float = 0.8f) {
        val maxMemory = runtime.maxMemory()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        
        if (usedMemory > maxMemory * thresholdPercent) {
            Log.w("Memory", "High memory usage: ${usedMemory * 100 / maxMemory}%")
            // è§¦å‘ GC æˆ–æ¸…ç†ç¼“å­˜
            System.gc()
        }
    }
}
```

## ğŸ› å¸¸è§é—®é¢˜æ’æŸ¥

### é—®é¢˜ 1: æ¨¡å‹åŠ è½½å¤±è´¥

**ç—‡çŠ¶**: `Interpreter` åˆ›å»ºå¤±è´¥ï¼Œè¿”å› null

**æ’æŸ¥æ­¥éª¤**:
```kotlin
fun diagnoseModelLoading(context: Context): String {
    val sb = StringBuilder()
    
    // 1. æ£€æŸ¥æ–‡ä»¶å­˜åœ¨
    val modelFile = File(context.filesDir, "models/Qwen2-VL-2B-Int4.mnn")
    sb.appendLine("Model file exists: ${modelFile.exists()}")
    sb.appendLine("Model file size: ${modelFile.length() / 1024 / 1024}MB")
    
    // 2. æ£€æŸ¥æ–‡ä»¶å¯è¯»
    sb.appendLine("Model file readable: ${modelFile.canRead()}")
    
    // 3. æ£€æŸ¥å†…å­˜
    val runtime = Runtime.getRuntime()
    val freeMemory = runtime.maxMemory() - runtime.totalMemory() + runtime.freeMemory()
    sb.appendLine("Available memory: ${freeMemory / 1024 / 1024}MB")
    
    // 4. å°è¯•åŠ è½½å¹¶æ•è·å¼‚å¸¸
    try {
        val interpreter = Interpreter(modelFile.absolutePath)
        sb.appendLine("Interpreter created: true")
        interpreter.release()
    } catch (e: Exception) {
        sb.appendLine("Interpreter creation failed: ${e.message}")
        sb.appendLine(e.stackTraceToString())
    }
    
    return sb.toString()
}
```

### é—®é¢˜ 2: æ¨ç†å´©æºƒ

**ç—‡çŠ¶**: è¿è¡Œæ¨ç†æ—¶åº”ç”¨å´©æºƒ

**å¸¸è§åŸå› **:
1. **OOM (å†…å­˜ä¸è¶³)**: æ¨¡å‹å¤ªå¤§ï¼Œè®¾å¤‡å†…å­˜ä¸å¤Ÿ
   - è§£å†³ï¼šé™ä½ batch sizeï¼Œä½¿ç”¨ INT4 é‡åŒ–
   
2. **è¾“å…¥å°ºå¯¸ä¸åŒ¹é…**: å›¾ç‰‡å°ºå¯¸ä¸æ¨¡å‹æœŸæœ›ä¸ç¬¦
   ```kotlin
   fun validateInput(image: Bitmap): Boolean {
       // Qwen2-VL é€šå¸¸æœŸæœ› 448x448
       return image.width == 448 && image.height == 448
   }
   ```
   
3. **åç«¯ä¸æ”¯æŒ**: å°è¯•ä½¿ç”¨ GPU ä½†è®¾å¤‡ä¸æ”¯æŒ
   ```kotlin
   fun selectBestBackend(interpreter: Interpreter): Session.Backend {
       val info = interpreter.getRuntimeInfo()
       return when {
           info.supportsVulkan -> Session.Backend.VULKAN
           info.supportsOpenCL -> Session.Backend.OPENCL
           else -> Session.Backend.CPU
       }
   }
   ```

### é—®é¢˜ 3: æ¨ç†ç»“æœä¹±ç 

**ç—‡çŠ¶**: è¾“å‡ºæ–‡æœ¬ä¸ºä¹±ç æˆ–æ— æ„ä¹‰å­—ç¬¦

**æ’æŸ¥**:
```kotlin
fun diagnoseOutput(outputTensor: Tensor): String {
    val data = outputTensor.floatData()
    
    return buildString {
        appendLine("Output shape: ${outputTensor.shape.contentToString()}")
        appendLine("Output size: ${data.size}")
        appendLine("First 20 values: ${data.take(20).joinToString()}")
        appendLine("Min value: ${data.minOrNull()}")
        appendLine("Max value: ${data.maxOrNull()}")
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆ token ID
        val validRange = 0..100000  // æ ¹æ®è¯è¡¨å¤§å°è°ƒæ•´
        val validTokens = data.count { it.toInt() in validRange }
        appendLine("Valid tokens: $validTokens / ${data.size}")
    }
}
```

### é—®é¢˜ 4: å“åº”é€Ÿåº¦æ…¢

**ä¼˜åŒ–æ¸…å•**:
- [ ] ä½¿ç”¨ GPU/Vulkan åç«¯
- [ ] å‡å°‘çº¿ç¨‹æ•°ï¼ˆè¿‡å¤šçº¿ç¨‹åè€Œæ…¢ï¼‰
- [ ] é¢„çƒ­æ¨¡å‹ï¼ˆé¦–æ¬¡æ¨ç†æ…¢æ˜¯æ­£å¸¸çš„ï¼‰
- [ ] ä½¿ç”¨å†…å­˜æ± å¤ç”¨ Tensor
- [ ] é™ä½è¾“å…¥å›¾ç‰‡åˆ†è¾¨ç‡

## ğŸ“Š æ€§èƒ½åŸºå‡†æµ‹è¯•

```kotlin
// test/BenchmarkTest.kt
@RunWith(AndroidJUnit4::class)
class BenchmarkTest {
    
    @Test
    fun benchmarkInference() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        val model = Qwen2VLModel(context)
        model.initialize()
        
        val bitmap = Bitmap.createBitmap(448, 448, Bitmap.Config.ARGB_8888)
        val prompt = "æ¨èä¸€é“èœ"
        
        // é¢„çƒ­
        repeat(3) { model.inference(bitmap, prompt) }
        
        // æ­£å¼æµ‹è¯•
        val times = mutableListOf<Long>()
        repeat(10) {
            val start = SystemClock.elapsedRealtime()
            model.inference(bitmap, prompt)
            times.add(SystemClock.elapsedRealtime() - start)
        }
        
        Log.d("Benchmark", "Avg: ${times.average()}ms")
        Log.d("Benchmark", "Min: ${times.minOrNull()}ms")
        Log.d("Benchmark", "Max: ${times.maxOrNull()}ms")
        
        model.release()
    }
}
```

## ğŸš€ å‘å¸ƒå‡†å¤‡

### 1. ProGuard è§„åˆ™

```proguard
# MNN
-keep class com.alibaba.mnn.** { *; }
-keepclassmembers class * {
    native <methods>;
}

# æ•°æ®ç±»
-keep class com.foodassistant.data.model.** { *; }

# Room
-keep class * extends androidx.room.RoomDatabase
-dontwarn androidx.room.paging.**
```

### 2. åº”ç”¨ç­¾å

```bash
# ç”Ÿæˆç­¾åå¯†é’¥
keytool -genkey -v -keystore foodassistant.keystore -alias foodassistant -keyalg RSA -keysize 2048 -validity 10000

# æ„å»ºå‘å¸ƒç‰ˆæœ¬
./gradlew assembleRelease
```

### 3. åº”ç”¨å•†åº—å‡†å¤‡

- [ ] å‡†å¤‡åº”ç”¨æˆªå›¾
- [ ] ç¼–å†™åº”ç”¨æè¿°ï¼ˆçªå‡ºæœ¬åœ°AIã€éšç§ä¿æŠ¤å–ç‚¹ï¼‰
- [ ] è®¾ç½®éšç§æ”¿ç­–
- [ ] é…ç½®åº”ç”¨åˆ†çº§
- [ ] æµ‹è¯•ä¸åŒè®¾å¤‡å…¼å®¹æ€§

---

è‡³æ­¤ï¼Œå®Œæ•´çš„é¤é£Ÿå†³ç­–åŠ©æ‰‹å¼€å‘æ–‡æ¡£å·²å®Œæˆã€‚ç¥å¼€å‘é¡ºåˆ©ï¼ğŸ‰
