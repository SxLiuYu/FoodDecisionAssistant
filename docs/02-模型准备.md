# 02 - æ¨¡å‹å‡†å¤‡æŒ‡å—

## ğŸ“¦ æ‰€éœ€æ¨¡å‹æ–‡ä»¶

| æ¨¡å‹ | ç”¨é€” | å¤§å° | æ ¼å¼ |
|------|------|------|------|
| Qwen2-VL-2B-Int4 | å¤šæ¨¡æ€æ¨ç†ï¼ˆæ ¸å¿ƒï¼‰ | ~1.5GB | .mnn |
| Whisper Tiny | è¯­éŸ³è¯†åˆ«ï¼ˆå¯é€‰ï¼‰ | ~75MB | .mnn |

## ğŸ”½ ä¸‹è½½æ¨¡å‹

### æ–¹å¼ä¸€ï¼šå®˜æ–¹ MNN è½¬æ¢ç‰ˆæœ¬ï¼ˆæ¨èï¼‰

#### Qwen2-VL-2B

```bash
# ModelScope ä¸‹è½½
https://modelscope.cn/models/qwen/Qwen2-VL-2B-Instruct

# HuggingFace ä¸‹è½½
https://huggingface.co/Qwen/Qwen2-VL-2B-Instruct
```

MNN å®˜æ–¹å·²æä¾›è½¬æ¢å¥½çš„æ¨¡å‹ï¼Œæœç´¢ï¼š
```
MNN Qwen2-VL æ¨¡å‹
æˆ–
MNN-LLM é¡¹ç›®ä¸­çš„ Qwen æ¨¡å‹
```

### æ–¹å¼äºŒï¼šæ‰‹åŠ¨è½¬æ¢

å¦‚æœå®˜æ–¹æ²¡æœ‰æä¾› MNN æ ¼å¼ï¼Œéœ€è¦è‡ªè¡Œè½¬æ¢ï¼š

#### æ­¥éª¤ 1: å®‰è£… MNN è½¬æ¢å·¥å…·

```bash
# å…‹éš† MNN
git clone https://github.com/alibaba/MNN.git
cd MNN

# æ„å»ºè½¬æ¢å·¥å…·
mkdir build && cd build
cmake .. -DMNN_BUILD_CONVERTER=ON
make -j4

# è½¬æ¢å·¥å…·è·¯å¾„
./MNNConvert --help
```

#### æ­¥éª¤ 2: ä¸‹è½½åŸå§‹æ¨¡å‹

```bash
# å®‰è£…ä¾èµ–
pip install transformers torch modelscope

# ä¸‹è½½æ¨¡å‹
python -c "
from modelscope import snapshot_download
model_dir = snapshot_download('qwen/Qwen2-VL-2B-Instruct', cache_dir='./models')
print(f'Downloaded to: {model_dir}')
"
```

#### æ­¥éª¤ 3: è½¬æ¢ä¸º ONNX

```bash
# å®‰è£…ä¾èµ–
pip install optimum[exporters]

# å¯¼å‡º ONNX
optimum-cli export onnx \
  --model ./models/Qwen2-VL-2B-Instruct \
  --task image-to-text \
  ./models/qwen2-vl-onnx/
```

#### æ­¥éª¤ 4: ONNX è½¬ MNN

```bash
# ä½¿ç”¨ MNNConvert
./MNNConvert \
  --framework ONNX \
  --modelFile ./models/qwen2-vl-onnx/model.onnx \
  --MNNModel ./models/Qwen2-VL-2B-Int4.mnn \
  --bizCode MNN \
  --weightQuantBits 4
```

## ğŸ’¾ æ¨¡å‹å­˜å‚¨æ–¹æ¡ˆ

### æ–¹æ¡ˆ A: é¦–æ¬¡å¯åŠ¨ä¸‹è½½ï¼ˆæ¨èï¼‰

```kotlin
// ModelDownloader.kt
class ModelDownloader(private val context: Context) {
    
    companion object {
        const val MODEL_URL = "https://your-cdn.com/models/Qwen2-VL-2B-Int4.mnn"
        const val MODEL_SIZE = 1572864000L // 1.5GB
        const val MODEL_PATH = "models/Qwen2-VL-2B-Int4.mnn"
    }
    
    suspend fun downloadModel(): Flow<DownloadProgress> = flow {
        val file = File(context.filesDir, MODEL_PATH)
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if (file.exists() && file.length() == MODEL_SIZE) {
            emit(DownloadProgress.Completed(file))
            return@flow
        }
        
        // åˆ›å»ºçˆ¶ç›®å½•
        file.parentFile?.mkdirs()
        
        // ä¸‹è½½
        val request = Request.Builder().url(MODEL_URL).build()
        val response = OkHttpClient().newCall(request).execute()
        
        response.body?.use { body ->
            val total = body.contentLength()
            val source = body.source()
            val sink = file.sink().buffer()
            
            var downloaded = 0L
            var lastEmit = 0L
            
            while (true) {
                val read = source.read(sink.buffer, 8192)
                if (read == -1L) break
                
                downloaded += read
                sink.emitCompleteSegments()
                
                // æ¯ 1% è¿›åº¦å‘å°„ä¸€æ¬¡
                if (downloaded - lastEmit > total / 100) {
                    emit(DownloadProgress.InProgress(downloaded, total))
                    lastEmit = downloaded
                }
            }
            
            sink.writeAll(source)
            sink.close()
            emit(DownloadProgress.Completed(file))
        }
    }
    
    sealed class DownloadProgress {
        data class InProgress(val downloaded: Long, val total: Long) : DownloadProgress()
        data class Completed(val file: File) : DownloadProgress()
        data class Error(val message: String) : DownloadProgress()
    }
}
```

### æ–¹æ¡ˆ B: åˆ†åŒ…ä¸Šä¼ åº”ç”¨å•†åº—

å¦‚æœåº”ç”¨å•†åº—æ”¯æŒå¤§æ–‡ä»¶æ‰©å±•ï¼š

```kotlin
// ä½¿ç”¨ Play Feature Delivery æˆ–ç±»ä¼¼æ–¹æ¡ˆ
val splitInstallManager = SplitInstallManagerFactory.create(context)

val request = SplitInstallRequest.newBuilder()
    .addModule("model_module")
    .build()

splitInstallManager.startInstall(request)
```

### æ–¹æ¡ˆ C: æœ¬åœ° adb æ¨é€ï¼ˆå¼€å‘è°ƒè¯•ï¼‰

```bash
# å¼€å‘æ—¶ç›´æ¥æ¨é€åˆ°è®¾å¤‡
adb push Qwen2-VL-2B-Int4.mnn /sdcard/Android/data/com.foodassistant/files/models/
```

## ğŸ“‚ æ¨¡å‹åŠ è½½ä»£ç 

```kotlin
// Qwen2VLModel.kt
class Qwen2VLModel(private val context: Context) {
    
    private var interpreter: Interpreter? = null
    private var session: Session? = null
    
    companion object {
        private const val TAG = "Qwen2VLModel"
        private const val MODEL_NAME = "Qwen2-VL-2B-Int4.mnn"
    }
    
    /**
     * åˆå§‹åŒ–æ¨¡å‹
     */
    fun initialize(): Boolean {
        return try {
            val modelFile = File(context.filesDir, "models/$MODEL_NAME")
            
            if (!modelFile.exists()) {
                Log.e(TAG, "Model file not found: ${modelFile.absolutePath}")
                return false
            }
            
            // åˆ›å»º MNN è§£é‡Šå™¨
            interpreter = Interpreter(modelFile.absolutePath)
            
            // é…ç½®ä¼šè¯
            val config = Session.Config()
            config.numThread = 4  // ä½¿ç”¨4çº¿ç¨‹
            
            // å°è¯•ä½¿ç”¨ GPU/Vulkan åŠ é€Ÿ
            val runtimeInfo = interpreter!!.getRuntimeInfo()
            if (runtimeInfo.supportsVulkan) {
                config.backend = Session.Backend.VULKAN
                Log.i(TAG, "Using Vulkan backend")
            } else {
                config.backend = Session.Backend.CPU
                Log.i(TAG, "Using CPU backend")
            }
            
            session = interpreter!!.createSession(config)
            
            Log.i(TAG, "Model initialized successfully")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize model", e)
            false
        }
    }
    
    /**
     * è¿è¡Œæ¨ç† - å›¾ç‰‡ + æ–‡æœ¬è¾“å…¥
     */
    fun inference(image: Bitmap, prompt: String): String {
        val session = this.session ?: throw IllegalStateException("Model not initialized")
        
        // 1. é¢„å¤„ç†å›¾ç‰‡
        val processedImage = preprocessImage(image)
        
        // 2. å‡†å¤‡è¾“å…¥ Tensor
        val inputTensor = prepareInputTensor(processedImage, prompt)
        
        // 3. è¿è¡Œæ¨ç†
        val outputTensor = session.run(inputTensor)
        
        // 4. è§£æè¾“å‡º
        return parseOutput(outputTensor)
    }
    
    /**
     * å›¾ç‰‡é¢„å¤„ç† - è°ƒæ•´ä¸ºæ¨¡å‹è¾“å…¥å°ºå¯¸
     */
    private fun preprocessImage(bitmap: Bitmap): Tensor {
        // Qwen2-VL æœŸæœ›çš„è¾“å…¥å°ºå¯¸
        val targetWidth = 448
        val targetHeight = 448
        
        // ç¼©æ”¾å›¾ç‰‡
        val scaled = Bitmap.createScaledBitmap(bitmap, targetWidth, targetHeight, true)
        
        // è½¬æ¢ä¸º RGB æ•°ç»„
        val pixels = IntArray(targetWidth * targetHeight)
        scaled.getPixels(pixels, 0, targetWidth, 0, 0, targetWidth, targetHeight)
        
        // å½’ä¸€åŒ–åˆ° [0, 1] å¹¶è½¬æ¢ä¸º NCHW æ ¼å¼
        val floatArray = FloatArray(3 * targetHeight * targetWidth)
        
        for (i in pixels.indices) {
            val pixel = pixels[i]
            val r = (pixel shr 16 and 0xFF) / 255.0f
            val g = (pixel shr 8 and 0xFF) / 255.0f
            val b = (pixel and 0xFF) / 255.0f
            
            // ImageNet å½’ä¸€åŒ– (æ ¹æ® Qwen2-VL å®é™…é¢„å¤„ç†è°ƒæ•´)
            floatArray[i] = (r - 0.48145466f) / 0.26862954f
            floatArray[i + targetHeight * targetWidth] = (g - 0.4578275f) / 0.26130258f
            floatArray[i + 2 * targetHeight * targetWidth] = (b - 0.40821073f) / 0.27577711f
        }
        
        return Tensor(shape = intArrayOf(1, 3, targetHeight, targetWidth), data = floatArray)
    }
    
    /**
     * å‡†å¤‡ç»„åˆè¾“å…¥ï¼ˆå›¾ç‰‡ + æ–‡æœ¬ï¼‰
     */
    private fun prepareInputTensor(imageTensor: Tensor, prompt: String): Map<String, Tensor> {
        // æ–‡æœ¬ç¼–ç ï¼ˆç®€åŒ–ä¸º Char ç¼–ç ï¼Œå®é™…åº”ä½¿ç”¨ tokenizerï¼‰
        val promptBytes = prompt.toByteArray(Charsets.UTF_8)
        val promptTensor = Tensor(shape = intArrayOf(1, promptBytes.size), 
                                   data = promptBytes.map { it.toFloat() }.toFloatArray())
        
        return mapOf(
            "image" to imageTensor,
            "prompt" to promptTensor
        )
    }
    
    /**
     * è§£ææ¨¡å‹è¾“å‡º
     */
    private fun parseOutput(outputTensor: Tensor): String {
        // å°†è¾“å‡º tensor è½¬æ¢ä¸ºæ–‡æœ¬
        val outputData = outputTensor.floatData()
        
        // è§£ç ä¸ºå­—ç¬¦ä¸²ï¼ˆå®é™…åº”ä½¿ç”¨ tokenizer è§£ç ï¼‰
        val bytes = outputData.map { it.toInt().toByte() }.toByteArray()
        return String(bytes, Charsets.UTF_8).trim { it <= ' ' }
    }
    
    /**
     * é‡Šæ”¾èµ„æº
     */
    fun release() {
        session?.release()
        interpreter?.release()
        session = null
        interpreter = null
    }
}
```

## ğŸ§ª æ¨¡å‹æµ‹è¯•

```kotlin
// ModelTest.kt
class ModelTest {
    
    @Test
    fun testModelLoading() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        val model = Qwen2VLModel(context)
        
        assertTrue(model.initialize())
        
        model.release()
    }
    
    @Test
    fun testInference() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        val model = Qwen2VLModel(context)
        
        model.initialize()
        
        // åˆ›å»ºæµ‹è¯•å›¾ç‰‡
        val bitmap = Bitmap.createBitmap(448, 448, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        canvas.drawColor(Color.RED)
        
        val result = model.inference(bitmap, "è¿™æ˜¯ä»€ä¹ˆé£Ÿç‰©ï¼Ÿ")
        
        assertTrue(result.isNotEmpty())
        Log.d("ModelTest", "Result: $result")
        
        model.release()
    }
}
```

## ğŸ“Š æ¨¡å‹æ€§èƒ½å‚è€ƒ

| è®¾å¤‡ | æ¨ç†æ—¶é—´ | å†…å­˜å ç”¨ | å¤‡æ³¨ |
|------|----------|----------|------|
| éªé¾™8 Gen3 | 2-3s | 2.5GB | æ¨è |
| éªé¾™8 Gen2 | 3-4s | 2.8GB | è‰¯å¥½ |
| å¤©ç‘9300 | 2-3s | 2.5GB | æ¨è |
| å¤©ç‘9200 | 3-4s | 2.8GB | è‰¯å¥½ |

## ğŸ“ ä¸‹ä¸€æ­¥

æ¨¡å‹å‡†å¤‡å®Œæˆåï¼Œè¿›å…¥ [03-æ ¸å¿ƒå¼€å‘.md](03-æ ¸å¿ƒå¼€å‘.md) å®ç°åº”ç”¨æ ¸å¿ƒåŠŸèƒ½ã€‚
